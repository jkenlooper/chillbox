#!/usr/bin/env sh

set -o errexit

apk update
apk add sed attr grep coreutils

addgroup dev
adduser -G dev -D dev
# TODO: Set password as expired to force user to reset when logging in

# A box that has been provisioned via the cloud provider should already have
# public keys added. This handles a locally provisioned box.
if [ ! -e /root/.ssh/authorized_keys ]; then
  mkdir -p /root/.ssh
  for github_username in ${developer_ssh_key_github_list}; do
    wget https://github.com/$github_username.keys -O - | tee -a /root/.ssh/authorized_keys
  done
  chown -R root:root /root/.ssh
  chmod -R 700 /root/.ssh
  chmod -R 644 /root/.ssh/authorized_keys
fi

# The dev user will also use the same keys as root.
mkdir -p /home/dev/.ssh
cp /root/.ssh/authorized_keys /home/dev/.ssh/
chown -R dev:dev /home/dev/.ssh
chmod -R 700 /home/dev/.ssh
chmod -R 644 /home/dev/.ssh/authorized_keys

# Use doas instead of sudo since sudo seems bloated.
apk add doas
cat <<DOAS_CONFIG > /etc/doas.d/doas.conf
permit persist dev as root
DOAS_CONFIG

# Configure sshd to only allow users with authorized_keys to ssh in. The root
# user is blocked from logging in. PAM needs to be added and enabled for it to
# work with the AuthorizedKeysFile and publickey method.
apk add openssh-server-pam

cat <<SSHD_CONFIG > /etc/ssh/sshd_config
AuthenticationMethods publickey
AuthorizedKeysFile .ssh/authorized_keys
KbdInteractiveAuthentication no
PasswordAuthentication no
PermitRootLogin no
PubkeyAuthentication yes
UsePAM yes
SSHD_CONFIG

sshd -t
rc-service sshd restart

## Support s6 init scripts.
# Only if not using container s6-overlay and using openrc instead.
apk add s6 s6-portable-utils
rc-update add s6-svscan boot

cat <<'ENVFILE' > /home/dev/.env
export IMMUTABLE_BUCKET_NAME="${immutable_bucket_name}"
export ARTIFACT_BUCKET_NAME="${artifact_bucket_name}"
export S3_ENDPOINT_URL="${s3_endpoint_url}"
export S3_ARTIFACT_ENDPOINT_URL="${s3_endpoint_url}"
export CHILLBOX_ARTIFACT="${chillbox_artifact}"
export CHILLBOX_SERVER_NAME="${chillbox_hostname}"
export CHILLBOX_SERVER_PORT=80
# TODO: switch to released chill version
#export PIP_CHILL="chill==0.9.0"
export PIP_CHILL="git+https://github.com/jkenlooper/chill.git@develop#egg=chill"
export SITES_ARTIFACT="${sites_artifact}"
export TECH_EMAIL="${tech_email}"
export ACME_SH_VERSION="3.0.1"
#export LETS_ENCRYPT_SERVER="letsencrypt"
export LETS_ENCRYPT_SERVER="letsencrypt_test"
ENVFILE
chown dev:dev /home/dev/.env
source /home/dev/.env

mkdir -p /run/secrets
chown -R dev:dev /run/secrets
chmod -R 600 /run/secrets
cat <<'AWSCREDENTIALS' > /run/secrets/awscredentials
export AWS_ACCESS_KEY_ID="${access_key_id}"
export AWS_SECRET_ACCESS_KEY="${secret_access_key}"
AWSCREDENTIALS
source /run/secrets/awscredentials

# TODO: Get site_secrets and decrypt to the /var/lib/?

#apk add --no-cache gnupg gnupg-dirmngr

## RUN NGINX
apk add nginx
nginx -v

## RUN CHILL
apk add \
  py3-pip \
  gcc \
  python3 \
  python3-dev \
  libffi-dev \
  build-base \
  musl-dev \
  make \
  git \
  sqlite
ln -s /usr/bin/python3 /usr/bin/python
python --version
pip install --upgrade pip
python -m pip install --disable-pip-version-check "$PIP_CHILL"
chill --version

## RUN AWS_CLI
apk add \
  jq \
  aws-cli
aws --version

## RUN SUPPORT_ENVSUBST
# gettext includes envsubst
apk add gettext

## letsencrypt acme.sh
echo "letsencrypt acme.sh"
mkdir -p /usr/local/bin/
cd /usr/local/bin/
tmp_acme_tar=$(mktemp)
wget -O $tmp_acme_tar https://github.com/acmesh-official/acme.sh/archive/refs/tags/$ACME_SH_VERSION.tar.gz
tmp_md5sum=$(mktemp)
echo "21f4b4b88df5d7fb89bf15df9a8a8c94  -" > $tmp_md5sum
cat $tmp_acme_tar | md5sum --check $tmp_md5sum
tar x -z -f $tmp_acme_tar --strip-components 1 acme.sh-$ACME_SH_VERSION/acme.sh
#mkdir -p /etc/acmesh
#mkdir -p /etc/acmesh/certs
acme.sh --install \
  --email $TECH_EMAIL \
  --server $LETS_ENCRYPT_SERVER \
  --no-profile
  #--home /etc/acmesh \
  #--accountconf /etc/acmesh/account.conf \
  #--cert-home /etc/acmesh/certs

## RUN CHILLBOX_ENV_NAMES
mkdir -p /etc/chillbox
cat <<'ENV_NAMES' > /etc/chillbox/env_names
$CHILLBOX_SERVER_NAME
$S3_ENDPOINT_URL
$IMMUTABLE_BUCKET_NAME
$ARTIFACT_BUCKET_NAME
$slugname
$version
$server_name
ENV_NAMES

## RUN SERVICES_DEPENDENCIES
apk add --no-cache \
  gcc \
  python3 \
  python3-dev \
  libffi-dev \
  build-base \
  musl-dev \
  zlib \
  openjpeg \
  libjpeg \
  tiff \
  freetype \
  fribidi \
  harfbuzz \
  jpeg \
  lcms2 \
  tcl \
  tk \
  freetype-dev \
  fribidi-dev \
  harfbuzz-dev \
  jpeg-dev \
  lcms2-dev \
  openjpeg-dev \
  tcl-dev \
  tiff-dev \
  tk-dev \
  zlib-dev

## COPY chillbox artifact
tmp_chillbox_artifact=$(mktemp)
aws \
  --endpoint-url "$S3_ARTIFACT_ENDPOINT_URL" \
  s3 cp s3://$ARTIFACT_BUCKET_NAME/chillbox/$CHILLBOX_ARTIFACT \
  $tmp_chillbox_artifact

cd /etc/nginx
tar x -z -f $tmp_chillbox_artifact nginx.conf

mkdir -p /etc/nginx/conf.d && cd /etc/nginx/conf.d
tar x -z -f $tmp_chillbox_artifact default.nginx.conf

mkdir -p /etc/chillbox && cd /etc/chillbox
tar x -z -f $tmp_chillbox_artifact templates

mkdir -p /etc/chillbox/bin
tar x -z -f $tmp_chillbox_artifact -C /etc/chillbox/bin --strip-components 1 bin


## WORKDIR /usr/local/src/
mkdir -p /usr/local/src/
cd /usr/local/src/

## RUN SITE_INIT

# TODO: make a backup directory of previous sites and then compare new sites to
# find any sites that should be deleted. This would only be applicable to server
# version; not docker version.
tmp_sites_artifact=$(mktemp)
aws --endpoint-url "$S3_ARTIFACT_ENDPOINT_URL" \
  s3 cp s3://$ARTIFACT_BUCKET_NAME/_sites/$SITES_ARTIFACT \
  $tmp_sites_artifact
mkdir -p /etc/chillbox/sites/
tar x -z -f $tmp_sites_artifact -C /etc/chillbox/sites --strip-components 1 sites

export server_port=$CHILLBOX_SERVER_PORT
current_working_dir=/usr/local/src
sites=$(find /etc/chillbox/sites -type f -name '*.site.json')
for site_json in $sites; do
  slugname=${site_json%.site.json}
  slugname=${slugname#/etc/chillbox/sites/}
  export slugname
  export server_name="$slugname.test"
  echo "$slugname"
  echo "$server_name"
  cd $current_working_dir

  # no home, or password for user
  adduser -D -h /dev/null -H "$slugname" || printf "Ignoring adduser error"

  aws --version
  export version="$(jq -r '.version' $site_json)"

  deployed_version=""
  if [ -e /srv/chillbox/$slugname/version.txt ]; then
    deployed_version=$(cat /srv/chillbox/$slugname/version.txt)
  fi
  if [ "$version" = "$deployed_version" ]; then
    echo "Versions match for $slugname site."
    continue
  fi

  tmp_artifact=$(mktemp)
  aws --endpoint-url "$S3_ARTIFACT_ENDPOINT_URL" \
    s3 cp s3://$ARTIFACT_BUCKET_NAME/${slugname}/$slugname-$version.artifact.tar.gz \
    $tmp_artifact
  slugdir=$current_working_dir/$slugname
  mkdir -p $slugdir
  chown -R $slugname:$slugname $slugdir

  # Stop all services in the $slugname directory and make backups
  find $slugname -depth -mindepth 1 -maxdepth 1 -type f -name '*.service_handler.json' \
    | while read -r existing_service_handler; do
      echo "Stopping existing service handler: $existing_service_handler"
      eval "$(jq -r '@sh "
      service_name=\(.name)
      service_lang_template=\(.lang)
      service_handler=\(.handler)
      service_secrets_config=\(.secrets_config)
      "' $existing_service_handler)"
      rc-service ${slugname}-${service_name} stop || printf "Ignoring"
      rc-update delete ${slugname}-${service_name} default || printf "Ignoring"
      rm -f /etc/init.d/${slugname}-${service_name} || printf "Ignoring"
      rm -rf /etc/services.d/${slugname}-${service_name} || printf "Ignoring"

      rm -rf $slugname/${service_handler}.bak.tar.gz
      rm -rf $slugname/${service_handler}.service_handler.json.bak
      rm -rf /var/lib/${slugname}/secrets/${service_secrets_config}.bak
      mv $slugname/${service_handler}.service_handler.json $slugname/${service_handler}.service_handler.json.bak
      test -e $slugname/${service_handler} \
        && tar c -f $slugname/${service_handler}.bak.tar.gz $slugname/${service_handler}
      test -n "$service_secrets_config" -a -e /var/lib/${slugname}/secrets/${service_secrets_config} \
        && mv /var/lib/${slugname}/secrets/${service_secrets_config} /var/lib/${slugname}/secrets/${service_secrets_config}.bak
  done

  # TODO Set nginx server for this $slugname to maintenance
  # Extract just the nginx directory from the tmp_artifact
  rm -rf $slugname/nginx.bak.tar.gz
  test -e $slugname/nginx \
    && tar c -f $slugname/nginx.bak.tar.gz $slugname/nginx
  rm -rf $slugname/nginx
  tar x -z -f $tmp_artifact $slugname/nginx
  chown -R $slugname:$slugname $slugdir
  echo "Extracted nginx service for $slugname"
  ls -al $slugname/

  # init services
  jq -c '.services // [] | .[]' /etc/chillbox/sites/$slugname.site.json \
    | while read -r service_obj; do
        test -n "${service_obj}" || continue

        cd $current_working_dir

        # Extract and set shell variables from JSON input
        eval "$(echo $service_obj | jq -r '@sh "
          service_name=\(.name)
          service_lang_template=\(.lang)
          service_handler=\(.handler)
          service_secrets_config=\(.secrets_config)
          "')"
        # Extract just the new service handler directory from the tmp_artifact
        tar x -z -f $tmp_artifact $slugname/${service_handler}
        chown -R $slugname:$slugname $slugdir
        # Save the service object for later use when updating or removing the service.
        echo $service_obj | jq -c '.' > $slugdir/$service_handler.service_handler.json
        eval $(echo $service_obj | jq -r '.environment // [] | .[] | "export " + .name + "=\"" + .value + "\""' \
          | envsubst "$(cat /etc/chillbox/env_names | xargs)")

        cd $slugdir/${service_handler}
        if [ "${service_lang_template}" = "flask" ]; then

          mkdir -p "/var/lib/${slugname}/${service_handler}"
          chown -R $slugname:$slugname "/var/lib/${slugname}"

          python -m venv .venv
          ./.venv/bin/pip install --disable-pip-version-check --compile -r requirements.txt .

          # TODO: init_db only when first installing?
          HOST=localhost \
          FLASK_ENV="development" \
          FLASK_INSTANCE_PATH="/var/lib/${slugname}/${service_handler}" \
          S3_ENDPOINT_URL=$S3_ARTIFACT_ENDPOINT_URL \
          SECRETS_CONFIG=/var/lib/${slugname}/secrets/${service_secrets_config} \
            ./.venv/bin/flask init-db

          chown -R $slugname:$slugname "/var/lib/${slugname}/"

          cat <<PURR > /etc/init.d/${slugname}-${service_name}
#!/sbin/openrc-run
name="${slugname}-${service_name}"
description="${slugname}-${service_name}"
user="$slugname"
group="$slugname"
supervisor=s6
s6_service_path=/etc/services.d/${slugname}-${service_name}
depend() {
  need s6-svscan net localmount
  after firewall
}
PURR
          chmod +x /etc/init.d/${slugname}-${service_name}

          mkdir -p /etc/services.d/${slugname}-${service_name}
          cat <<PURR > /etc/services.d/${slugname}-${service_name}/run
#!/usr/bin/execlineb -P
s6-setuidgid $slugname
cd $slugdir/${service_handler}
PURR
          echo $service_obj | jq -r '.environment // [] | .[] | "s6-env " + .name + "=\"" + .value + "\""' \
            | envsubst "$(cat /etc/chillbox/env_names | xargs)" \
            >> /etc/services.d/${slugname}-${service_name}/run
          cat <<PURR >> /etc/services.d/${slugname}-${service_name}/run
s6-env HOST=localhost \
s6-env FLASK_ENV=development
s6-env FLASK_INSTANCE_PATH="/var/lib/${slugname}/${service_handler}"
s6-env SECRETS_CONFIG=/var/lib/${slugname}/secrets/${service_secrets_config}
s6-env S3_ENDPOINT_URL=${S3_ENDPOINT_URL}
s6-env ARTIFACT_BUCKET_NAME=${ARTIFACT_BUCKET_NAME}
s6-env IMMUTABLE_BUCKET_NAME=${IMMUTABLE_BUCKET_NAME}
./.venv/bin/start
PURR
          chmod +x /etc/services.d/${slugname}-${service_name}/run
          rc-update add ${slugname}-${service_name} default
          rc-service ${slugname}-${service_name} start

        elif [ "${service_lang_template}" = "chill" ]; then

          # init chill
          su -p -s /bin/sh $slugname -c 'chill initdb'
          su -p -s /bin/sh $slugname -c 'chill load --yaml chill-data.yaml'

          if [ "${freeze}" = "true" ]; then
            echo 'freeze';
            su -p -s /bin/sh $slugname -c 'chill freeze'
          else
            echo 'dynamic';

            cat <<PURR > /etc/init.d/${slugname}-${service_name}
#!/sbin/openrc-run
name="${slugname}-${service_name}"
description="${slugname}-${service_name}"
user="$slugname"
group="$slugname"
supervisor=s6
s6_service_path=/etc/services.d/${slugname}-${service_name}
depend() {
  need s6-svscan net localmount
  after firewall
}
PURR
            chmod +x /etc/init.d/${slugname}-${service_name}

            mkdir -p /etc/services.d/${slugname}-${service_name}

            cat <<MEOW > /etc/services.d/${slugname}-${service_name}/run
#!/usr/bin/execlineb -P
s6-setuidgid $slugname
cd $slugdir/${service_handler}
MEOW
            echo $service_obj | jq -r '.environment // [] | .[] | "s6-env " + .name + "=\"" + .value + "\""' \
              | envsubst "$(cat /etc/chillbox/env_names | xargs)" \
              >> /etc/services.d/${slugname}-${service_name}/run
            cat <<PURR >> /etc/services.d/${slugname}-${service_name}/run
chill serve
PURR

            chmod +x /etc/services.d/${slugname}-${service_name}/run
            rc-update add ${slugname}-${service_name} default
            rc-service ${slugname}-${service_name} start

          fi

        else
          echo "ERROR: The service 'lang' template: '${service_lang_template}' is not supported!"
          exit 12
        fi

      done

  # TODO Handle errors if any service failed to start and rollback to the backup.

  echo "Finished setting up services for $site_json"

  eval $(jq -r \
      '.env[] | "export " + .name + "=" + .value' /etc/chillbox/sites/$slugname.site.json \
        | envsubst "$(cat /etc/chillbox/env_names | xargs)")

  site_env_names=$(jq -r '.env[] | "$" + .name' /etc/chillbox/sites/$slugname.site.json | xargs)
  site_env_names="$(cat /etc/chillbox/env_names | xargs) $site_env_names"

  # Set crontab
  tmpcrontab=$(mktemp)
  # TODO Should preserve any existing crontab entries?
  #      crontab -u $slugname -l || printf '' > $tmpcrontab
  # Append all crontab entries, use envsubst replacements
  jq -r '.crontab // [] | .[]' /etc/chillbox/sites/$slugname.site.json  \
    | envsubst "${site_env_names}" \
    | while read -r crontab_entry; do
        test -n "${crontab_entry}" || continue
        echo "${crontab_entry}" >> $tmpcrontab
      done
  cat $tmpcrontab | crontab -u $slugname -
  rm -f $tmpcrontab

  cd $slugdir
  # install site root dir
  mkdir -p $slugdir/nginx/root
  rm -rf /srv/$slugname
  mkdir -p /srv/$slugname
  mv $slugdir/nginx/root /srv/$slugname/
  chown -R nginx /srv/$slugname/
  mkdir -p /var/log/nginx/
  rm -rf /var/log/nginx/$slugname/
  mkdir -p /var/log/nginx/$slugname/
  chown -R nginx /var/log/nginx/$slugname/
  # Install nginx templates that start with slugname
  mv $slugdir/nginx/templates/$slugname*.nginx.conf.template /etc/chillbox/templates/
  rm -rf $slugdir/nginx
  # Set version
  mkdir -p /srv/chillbox/$slugname
  chown -R nginx /srv/chillbox/$slugname/
  echo "$version" > /srv/chillbox/$slugname/version.txt
done


## RUN NGINX_CONF
mkdir -p /srv/chillbox
chown -R nginx /srv/chillbox/
mkdir -p /var/cache/nginx
chown -R nginx /var/cache/nginx
mkdir -p /var/log/nginx/
mkdir -p /var/log/nginx/chillbox/
chown -R nginx /var/log/nginx/chillbox/
rm -rf /etc/nginx/conf.d/
mkdir -p /etc/nginx/conf.d/
chown -R nginx /etc/nginx/conf.d/

cat <<'HISS' > reload-templates.sh
#!/usr/bin/env sh

export server_port=$CHILLBOX_SERVER_PORT
sites=$(find /etc/chillbox/sites -type f -name '*.site.json')
for site_json in $sites; do
  slugname=${site_json%.site.json}
  slugname=${slugname#/etc/chillbox/sites/}
  export slugname
  export server_name="$slugname.test"
  export version="$(jq -r '.version' $site_json)"

  eval $(jq -r \
      '.env[] | "export " + .name + "=" + .value' $site_json \
        | envsubst "$(cat /etc/chillbox/env_names | xargs)")

  site_env_names=$(jq -r '.env[] | "$" + .name' /etc/chillbox/sites/$slugname.site.json | xargs)
  site_env_names="$(cat /etc/chillbox/env_names | xargs) $site_env_names"

  template_path=/etc/chillbox/templates/$slugname.nginx.conf.template
  template_file=$(basename $template_path)
  envsubst "${site_env_names}" < $template_path > /etc/nginx/conf.d/${template_file%.template}
done

template_path=/etc/chillbox/templates/chillbox.nginx.conf.template
template_file=$(basename $template_path)
envsubst '$CHILLBOX_SERVER_NAME $CHILLBOX_SERVER_PORT' < $template_path > /etc/nginx/conf.d/${template_file%.template}
HISS

cat <<'HISS' > dev.sh
#!/usr/bin/env sh

/usr/local/src/reload-templates.sh
nginx -t
nginx -g 'daemon off;'
HISS

chmod +x reload-templates.sh
/usr/local/src/reload-templates.sh

chmod +x dev.sh
chown -R nginx /etc/nginx/conf.d/

## RUN DEV_USER
chown dev /etc/chillbox/env_names

## acme.sh certs
# Create certs for all sites
mkdir -p /var/lib/acmesh
chown -R nginx:nginx /var/lib/acmesh
for site_json in $sites; do
  slugname=$${site_json%.site.json}
  slugname=$${slugname#/etc/chillbox/sites/}
  export slugname
  domain_list=$(jq -r '.domain_list[]' $site_json)
  # Reset and add the --domain option for each to the $@ variable
  set -- ""
  for domain in $domain_list; do
    set -- "$@" --domain $domain
  done

  acme.sh --issue \
    --server $LETS_ENCRYPT_SERVER \
    "$@" \
    --webroot /srv/$slugname/root/

  acme.sh --install-cert \
    --server $LETS_ENCRYPT_SERVER \
    "$@" \
    --cert-file /var/lib/acmesh/$slugname.cer \
    --key-file /var/lib/acmesh/$slugname.key \
    --reloadcmd 'nginx -t && nginx -s reload'
done

nginx -t
rc-update add nginx default
rc-service nginx start
