#!/usr/bin/env sh
set -o errexit

set -x
# TODO use a debug mode flag.
# cp "$0" /root/debug-user-data.sh

work_dir="$(dirname "$0")"

install_packages() {
#{#-
# Don't upgrade the kernel in a user-data script (no 'apk upgrade' here).
# Use of 'apk update' is okay.
# An upgrade of the kernel should only be done if it can reboot afterwards before
# trying to run other commands.
#}
  apk update
  apk add \
    -q --no-progress \
    attr \
    coreutils \
    doas \
    nftables \
    openssh \
    openssl \
    s6 \
    s6-portable-utils \
    shadow

  rc-update add s6-svscan boot

  # Need to restart sshd to generate hostkeys
  rc-service sshd restart
}


init_user() {
  #{#-
  # Only the owner is added initially in the user-data script.
  #  This is because only a single list of public ssh keys are provided to the
  #  cloud host api. These get set to /root/.ssh/authorized_keys which the
  #  user-data script will copy over to the owner's .ssh/authorized_keys.
  #  Having other users being set up initially would include all their public
  #  ssh keys as well for every user being created. The other login users could
  #  be added later in a remote run task.

  # Configure doas to not allow root privileges on a lot of stuff including not
  # allowing any user to be root?
  # Set the owner of the private key to be root, use a service that watches for
  # file events in order to decrypt files. This way no user has access to the
  # private key and the private key stays in a tmpfs mount which will be lost if
  # the server reboots.
  #}
useradd -m -U -p '{{ chillbox_user.password_hash }}' '{{ chillbox_user.name }}'

#{#-
# Include the user to the chillconf group so login users can
# modify the /etc/chillbox/chillbox.config file.
#}
groupadd --system chillconf
usermod -a -G chillconf '{{ chillbox_user.name }}'

#{#-
# Set password as expired to force user to reset when logging in
#}
passwd --expire '{{ chillbox_user.name }}'

mkdir -p '/home/{{ chillbox_user.name }}/.ssh'
cat <<'HERE_PUBLIC_SSH_KEYS' > '/home/{{ chillbox_user.name }}/.ssh/authorized_keys'
{{ chillbox_user["public_ssh_key"] | join('\n') }}
HERE_PUBLIC_SSH_KEYS

chown -R '{{ chillbox_user.name }}:{{ chillbox_user.name }}' '/home/{{ chillbox_user.name }}/.ssh'
chmod -R 700 '/home/{{ chillbox_user.name }}/.ssh'
chmod -R 644 '/home/{{ chillbox_user.name }}/.ssh/authorized_keys'

mkdir -p /etc/doas.d
cat <<DOAS_CONFIG > /etc/doas.d/chillbox.doas.conf
permit persist {{ chillbox_user.name }} as root
DOAS_CONFIG
chmod 0600 /etc/doas.d/chillbox.doas.conf
doas -C /etc/doas.d/chillbox.doas.conf && echo "doas config ok"

#{#-
# Configure sshd to only allow users with authorized_keys and a password to ssh
# in. The root user is blocked from logging in. Note that UsePAM is not used
# because busybox login does not support PAM. Even installing the
# openssh-server-pam package it configures openssh to not use PAM.
# https://git.alpinelinux.org/aports/tree/main/openssh/APKBUILD?h=3.17-stable#n146
#}

cat <<SSHD_CONFIG > /etc/ssh/sshd_config
AuthenticationMethods publickey,password
AuthorizedKeysFile .ssh/authorized_keys
KbdInteractiveAuthentication no
PasswordAuthentication yes
PermitRootLogin no
PubkeyAuthentication yes
SSHD_CONFIG

sshd -t
# Hacky way of getting openrc to show that sshd is running.
pkill sshd || printf ''
rc-service sshd start || printf ''
}


nftables_setup() {
#{#- Include the nftables script that was defined for this server.  #}
cat <<'HERE' > "$work_dir/chillbox.nft"
{% include [nft_script, 'chillbox.nft', 'local:chillbox.nft', 'chillbox:chillbox.nft'] %}
HERE
chmod u+x "$work_dir/chillbox.nft"
#{#-
## If running into an error like this:
## mnl.c:60: Unable to initialize Netlink socket: Protocol not supported
## This is because the kernel was upgraded via the 'apk upgrade' command. It would require a reboot.
#}
"$work_dir/chillbox.nft"
}

create_scripts() {
cat <<'DECRYPT_FILE_HERE' > "/usr/local/bin/decrypt-file"
{% include [scripts_decrypt_file, 'local:scripts/decrypt-file', 'chillbox-scripts:decrypt-file'] %}
DECRYPT_FILE_HERE
chmod +x "/usr/local/bin/decrypt-file"

cat <<'DECRYPT_FILE_HERE' > "/usr/local/bin/encrypt-file"
{% include [scripts_encrypt_file, 'local:scripts/encrypt-file', 'chillbox-scripts:encrypt-file'] %}
DECRYPT_FILE_HERE
chmod +x "/usr/local/bin/encrypt-file"

cat <<'CREATE_ASYMMETRIC_KEY_HERE' > "/usr/local/bin/create-asymmetric-key"
{% include [scripts_create_asymmetric_key, 'local:scripts/create-asymmetric-key', 'chillbox-scripts:create-asymmetric-key'] %}
CREATE_ASYMMETRIC_KEY_HERE
chmod +x "/usr/local/bin/create-asymmetric-key"
}

create_dirs() {
#{#-
## Include script to create initial directories and set the owner and permissions as needed.
## This is to support upload of path objects defined in the chillbox config toml.
#}
cat <<'CHILLBOXUSERDATACREATEDIRS' > "$work_dir/chillbox-user-data-create_dirs.sh"
{% include [create_dirs_script, 'TODOcreate_dirs.sh', 'local:create_dirs.sh', 'chillbox-server:create_dirs.sh', 'chillbox:create_dirs.sh'] ignore missing %}
CHILLBOXUSERDATACREATEDIRS
#{#-
## Only need to execute the create_dirs.sh script if it was defined.
#}
if [ -s "$work_dir/chillbox-user-data-create_dirs.sh" ]; then
  chmod u+x "$work_dir/chillbox-user-data-create_dirs.sh"
  "$work_dir/chillbox-user-data-create_dirs.sh"
fi
}

install_packages
nftables_setup
init_user
create_scripts
create_dirs

mkdir -p /root/chillbox/key
key_name="$(hostname -s | xargs)"
/usr/local/bin/create-asymmetric-key -n "$key_name" -d /root/chillbox/key
mkdir -p /usr/local/share/chillbox/key/
mv "/root/chillbox/key/$key_name.public.pem" /usr/local/share/chillbox/key/
chmod 644 "/usr/local/share/chillbox/key/$key_name.public.pem"
