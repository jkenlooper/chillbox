# syntax=docker/dockerfile:1.3.0-labs

# docker pull hashicorp/terraform:1.2.0-alpha-20220328
# sha256:94c01aed14a10ef34fad8d8c7913dd605813076ecc824284377d7f1375aa596c

FROM hashicorp/terraform:1.2.0-alpha-20220328@sha256:94c01aed14a10ef34fad8d8c7913dd605813076ecc824284377d7f1375aa596c

RUN <<INSTALL
apk update
apk add \
  gpg \
  gpg-agent

INSTALL

RUN <<CREATE_SCRIPTS

cat <<'ENCRYPT_TFVARS_SH' > /usr/local/bin/doterra-encrypt_tfvars.sh
# This script prompts for the DigitalOcean access keys and encrypts them to
# files.  The GPG key is created if it doesn't already exist and is named with
# the environment.  The encrypted files will be placed in the environment's directory.

# TF_VAR_* variables from the output of decrypting each
# encrypted file that was generated by the encrypt_tfvars.sh script.

# Usage: Source the script and pass in the environment directory.
# Example for development:
# source encrypt_tfvars.sh development


if [ -d "$1" ]; then

  gpg_key_name="chillbox_$1"

  # Create an encryption key if one doesn't already exist.  Set expiration to
  # 'never' and use a future-default algorithm to prevent future issues.
  gpg --quick-generate-key "${gpg_key_name}" default encrypt never
  qgk_err_code=$?

  if [ $qgk_err_code -eq 2 -o $qgk_err_code -eq 1 -o $qgk_err_code -eq 0 ]; then
    if [ $qgk_err_code -eq 2 -o $qgk_err_code -eq 1 ]; then
      echo "Using existing key: ${gpg_key_name}"
    elif [ $qgk_err_code -eq 0 ]; then
      echo "Using new key: ${gpg_key_name}"
    else
      echo "error $qgk_err_code"
    fi
    TEMP_DIR=$(mktemp -d)

    source secure_tfvars.sh
    echo "$TF_VAR_do_token" > $TEMP_DIR/do_token
    echo "$TF_VAR_do_spaces_access_key_id" > $TEMP_DIR/do_spaces_access_key_id
    echo "$TF_VAR_do_spaces_secret_access_key" > $TEMP_DIR/do_spaces_secret_access_key
    echo "$TF_VAR_do_app_spaces_access_key_id" > $TEMP_DIR/do_app_spaces_access_key_id
    echo "$TF_VAR_do_app_spaces_secret_access_key" > $TEMP_DIR/do_app_spaces_secret_access_key

    for secret in do_token do_spaces_access_key_id do_spaces_secret_access_key do_app_spaces_access_key_id do_app_spaces_secret_access_key; do
      gpg --encrypt --recipient "${gpg_key_name}" --armor --output $1/.$secret \
        --comment "Chillbox tfvars" \
        --comment "$1" \
        --comment "TF_VAR_$secret" \
        $TEMP_DIR/$secret
      shred -z -u $TEMP_DIR/$secret
    done

  else
    echo "Failed to encrypt secret."
  fi

else
  echo "First arg should be a directory where the encrypted files will go."
fi
ENCRYPT_TFVARS_SH

cat <<'INIT_SH' > /usr/local/bin/doterra-init.sh
source /usr/local/bin/doterra-encrypt_tfvars.sh $WORKSPACE
INIT_SH
chmod +x /usr/local/bin/doterra-init.sh


cat <<'DOTERRA_SH' > /usr/local/bin/doterra.sh
#!/usr/bin/env sh
set -o errexit

terraform_command=$1
if [ "$terraform_command" != "plan" ] && [ "$terraform_command" != "apply" ] && [ "$terraform_command" != "destroy" ]; then
  echo "This command is not supported when using $0 script."
fi

cd /usr/local/src/chillbox-terraform

terraform workspace select $WORKSPACE || \
  terraform workspace new $WORKSPACE

test "$WORKSPACE" = "$(terraform workspace show)" || (echo "Sanity check to make sure workspace selected matches environment has failed." && exit 1)

    #-var-file="$script_dir/config.tfvars" \
    #-var-file="$script_dir/private.tfvars" \
    #-var "project_version=$project_version" \
    #-var "project_description=$project_description"
terraform $terraform_command

DOTERRA_SH
chmod +x /usr/local/bin/doterra.sh

CREATE_SCRIPTS


WORKDIR /usr/local/src/chillbox-terraform

ARG ALPINE_CUSTOM_IMAGE=""
ARG ALPINE_CUSTOM_IMAGE_CHECKSUM=""
RUN <<WGET_ALPINE_CUSTOM_IMAGE
set -o errexit
test -n "${ALPINE_CUSTOM_IMAGE}"
test -n "${ALPINE_CUSTOM_IMAGE_CHECKSUM}"
wget $ALPINE_CUSTOM_IMAGE
alpine_custom_image_file="$(basename ${ALPINE_CUSTOM_IMAGE})"
md5sum "${alpine_custom_image_file}"
echo "${ALPINE_CUSTOM_IMAGE_CHECKSUM}  ${alpine_custom_image_file}" | md5sum -c
cat <<HERE > alpine_custom_image.auto.tfvars
alpine_custom_image = "${alpine_custom_image_file}"
HERE
WGET_ALPINE_CUSTOM_IMAGE

COPY . .

ARG WORKSPACE=development
ENV WORKSPACE=${WORKSPACE}

ARG SITES_ARTIFACT=""
ENV SITES_ARTIFACT=${SITES_ARTIFACT}
ARG CHILLBOX_ARTIFACT=""
ENV CHILLBOX_ARTIFACT=${CHILLBOX_ARTIFACT}
ARG SITES_MANIFEST=""
ENV SITES_MANIFEST=${SITES_MANIFEST}

RUN <<SITES_ARTIFACT_CONFIG
cat <<HERE > chillbox_sites.auto.tfvars
sites_artifact = "${SITES_ARTIFACT}"
chillbox_artifact = "${CHILLBOX_ARTIFACT}"
sites_manifest = "${SITES_MANIFEST}"
# TODO add site domain list
HERE
# Set the immutable_bucket_name and artifact_bucket_name from the infra output.
jq -r 'map_values(.value) | to_entries | .[] | "\(.key) = \"\(.value)\""' \
  terraform-010-infra.output.json >> chillbox_sites.auto.tfvars
SITES_ARTIFACT_CONFIG

RUN <<SETUP
addgroup dev
adduser -G dev -D dev
chown -R dev:dev .

su dev -c "terraform init"
su dev -c "terraform workspace new $WORKSPACE"
SETUP


VOLUME /usr/local/src/chillbox-terraform/.terraform
VOLUME /usr/local/src/chillbox-terraform/terraform.tfstate.d

USER dev

# Isolate install of terraform from host machine
# Separate run of terrafrom container per environment/workspace?
# Simplify use of gpg to keep sensitive files secure in a volume.

#chillbox.tf
#decrypt_tfvars.sh
#encrypt_tfvars.sh
#main.tf
#secure_tfvars.sh
#variables.tf
#
#private.auto.tfvars

# Store terraform state in this directory.
#VOLUME /var/lib/chillbox-terraform

#development
#test
#acceptance
#production
